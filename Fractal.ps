#define NUM_LIGHTS 4

Texture2D shaderTexture1 : register(t0);
Texture2D shaderTexture2 : register(t1);
Texture2D alphaMap : register(t2);
Texture2D normalMap : register(t3);
SamplerState SampleType : register(s0);

cbuffer LightColorBuffer : register(b1)
{
    float4 diffuseColor[NUM_LIGHTS];
};

cbuffer UtilBuffer: register(b0)
{
    float time;
    float pad2;
    float pad3;
    float pad4;
};

struct PixelInputType
{
    float4 position : SV_POSITION;
    float2 tex : TEXCOORD0;
    float3 normal : NORMAL;
    float3 tangent : TANGENT;
    float3 binormal : BINORMAL;
    float3 lightPos[NUM_LIGHTS] : TEXCOORD2;
    float3 viewDirection : TEXCOORD1;
    float fogFactor : FOG;
    float clip : SV_ClipDistance0;
};

cbuffer LightBuffer : register(b2)
{
    float4 ambientColor;
    float4 diffuseDirColor;
    float3 lightDirection;
    float specularPower;
    float4 specularColor;
};

cbuffer TextureTranslationBuffer : register(b3)
{
    float2 translation;
    float timeMultiplier;
    float texPad;
};

cbuffer AlphaBuffer : register(b4)
{
    float alphaBlend;
    float alphaPad1;
    float alphaPad2;
    float alphaPad3;
};

float4 PS_MAIN(PixelInputType input) : SV_TARGET
{
    float2 uv = input.position * 2.0f - float2(1200, 900);
    uv /= 900;

    float2 uv0 = uv;

    float t = sin(time / 10) * 30;

    uv = frac(uv * t + length(uv0)) - 0.5f;

    float d = length(uv);
    float3 col = 0;

    for (int i = 0; i < d * 10; i++)
    {
        col += cos(i * d * t) * sin(i + d + t);
        uv = uv0 * i;
        col += uv.x * uv.y;
    }

    col.r = ceil(col.r);
    col.gb = round(col.gb);
    // col = round(col);

    return float4(col, 1);
}